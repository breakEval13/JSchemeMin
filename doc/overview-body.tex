\chapter*{Scheme简介}

本文给出\rsevenrs 的小语言的概述.
此概述的目的为说明理解\rsevenrs{}报告所需的基本概念, 该报告被组织为参考手册.
因此, 本概述不是语言的完整介绍，也不在任何方面精确或在任何意义下规范.

\vest 跟随Algor，Scheme是一种静态作用域的语言。一个变量的每次使用关联一个词法决定的绑定。

\vest Scheme不同于显式类型. 类型与对象（又称值）而不是变量关联。（有些作者称隐式类型为类型、弱类型或动态类型。）隐式类型语言包括Python，Ruby，Smalltalk和其它Lisp方言。显式类型语言（有时称为强类型或静态类型语言）包括Algor 60，C，Java，C \#，Haskell，和ML.

\vest 所有在Scheme计算过程中创建的对象，包括过程和延续，有无限的层次。没有任何Scheme对象被销毀。Scheme实现（通常）不用光存储空间的原因是它们被允许回收可以证明不可能影响任何未来计算的对象占用的存储空间。其他语言中，大多数对象无限制的语言包括C\#，Java，Haskell，大多数的Lisp方言，ML，Python，Ruby，和Smalltalk。

\vest Scheme的实现必须正确地尾递归。这容许在常数空间中执行迭代计算，即使迭代计算的语法描述为递归过程。因此，用正确的尾部递归实现，可以用自调用机制来表示迭代，因此，特殊的迭代构造只是有用的句法糖。

\vest Scheme是第一种过程作为公民对象的语言之一支持程序的一种对象在自己的权利。程序可以动态创建，存储在数据结构中，作为返回值等等。有这性能的其他语言包括Common Lisp，Haskell，ML，Ruby，和Smalltalk。

\vest Scheme的一个标志性特性为继续，它在大多数语言只在背后工作, 而在这里有``头等''地位。头等继续对实现广泛的高级控制结构有用，包括非本地退出、回溯和协程。

在Scheme，参数在过程取得控制前求值，不管过程是否需要它们的值。 C、 C\#、 Common Lisp、 Python、Ruby和Smalltalk亦然。这与Haskell的惰性求值或Algol 60的按名调用语义不同，它们在过程需要时才求值参数表达式。

Scheme的算术模型提供丰富的数值类型和操作。进一步它区分\textit{精确}和\textit{非精确数}：实际上一个精确数精确对应于一个数，而非精确数为涉及舍入或其它近似的数。

\chapter{基本类型}

Scheme处理\textit{对象}，也称为值\textit{值}。Scheme对象组织为称为\textit{类型}的值集合。本章给出Scheme语言重要基本类型的概述。

\begin{note}
  因为Scheme为隐式类型的，Scheme语景下 \textit{类型} 一词使用与其它语言特别是显式类型语言语景下不同。
\end{note}

\paragraph{数}

Scheme支持广泛的数值类型，包括任意精度整数、有理数、复数和多种非精确数。

\paragraph{布尔值}

布尔值即直值，可以是真或假。在Scheme, ``假''对象记为 \schfalse{}，``真''对象记为 \schtrue{}。但在大多数要求真值的场合，非假的对象都被当作真。

\paragraph{序偶和列表}

序偶为有两个分量的数据结构。最常用于表示（单向链）列表，其中首分量(``car'')表示列表首个元素，次分量(``car'')表示余下的列表。Scheme 也有独特的空列表，用于列表中最后一个序偶的cdr。

\paragraph{符号}

符号是表示一个字符串（它的\textit{名字}）的对象。与字符串不同，两个名字相同的符号不可区分。符号有很多应用，例如可用来模仿其它语言的枚举。

在 \rsevenrs，不同于 \rfivers，符号和标识符区分大小写。

\paragraph{字符}

Scheme字符大致对应于文本字符。更准确地，它同构于Unicode标准中\textit{标量值}的子集，可能有与实现有关的扩展。

\paragraph{字符串}

字符串为字符的定长序列，从而表示Unicode文本。

\paragraph{向量}

向量和列表同为表示任意对象的有限序列的的线性数据结构。列表的元素通过遍历序偶链来存取，而向量的元素由整数下标存取。因此，向量比列表更适合随机访问。

\paragraph{位向量}

位向量类似于向量，除了它的内容为\textit{字节}, 即从0到255的精确整数。

\paragraph{过程}

过程在Scheme为值。

\paragraph{记录}

记录为结构化的值，是零个或更多个域\textit{域}的聚合，每一个存放单个位置。记录组织为\textit{记录类型}。一个记录类型可定义一个谓词、构造器、域访问器、域修改器。

\paragraph{端口}

端口表示输入输出装置。对于Scheme，输入端口是一个可通过命令提供数据的Scheme对象，而输出端口是一个可接受数据的Scheme对象.

\chapter{表达式}

Scheme代码大部分主要元素为\textit{表达式}。表达式可被\textit{求值}, 提供 \textit{值} (实际上任意多个值)。最基本的表达式为字面值表达式:

\begin{scheme}
\schtrue{} \ev \schtrue
23 \ev 23%
\end{scheme}

这记号指 \schtrue{} 求值为\schtrue{}，即``真''的值，而{\cf 23} 求值为表示23的数。

复合表达式由括号和子表达式组成。第一个子表达式确定操作; 其余子表达式为操作数:
%
\begin{scheme}
(+ 23 42) \ev 65
(+ 14 (* 23 42)) \ev 980%
\end{scheme}
%
在第一个例子，{\cf +} 是一个内置加法操作的名字，{\cf 23} 和 {\cf 42} 为操作数。表达式 {\cf (+ 23 42)} 读作 ``23 和
42的和''。复合表达式可嵌套---第二个表达式读作 ``14 和 23 与 42 的积的和''。

如这些例子指出的，Scheme的复合表达式都用前缀记法。结果，需要括号指示结构。于是, 在数学和其它编程语言中常见的``省略'' 括号在Scheme是不容许的。

和很多其它语言一样，空白(包括行结束符)在分隔子表达式时不重要，可用于显示结构。

\chapter{变量和绑定}

Scheme容许标识符表示包含值的位置。这些标识符称为变量。在很多情况，特别是位置在创建后没有修改过时，把变量直接想成其值是有用的。

\begin{scheme}
(let ((x 23)
      (y 42))
  (+ x y)) \ev 65%
\end{scheme}

在本例，{\cf let} 开始的表达式为一个绑定构造。 {\cf let}表达式把{\cf x} 绑定到 23，把{\cf y} 绑定到 42。这些绑定在且仅在{\cf let}的\textit{体}可见。

\chapter{定义}

用 {\cf let} 表达式绑定的变量是\textit{本地}的，因为绑定仅在{\cf let}的体可见。Scheme也容许创建顶层绑定如下：

\begin{scheme}
(define x 23)
(define y 42)
(+ x y) \ev 65%
\end{scheme}

(These are actually ``top-level'' in the body of a top-level program or library.)

The first two parenthesized structures are \textit{definitions}; they
create top-level bindings, binding {\cf x} to 23 and {\cf y} to 42.
Definitions are not expressions, and cannot appear in all places
where an expression can occur.  Moreover, a definition has no value.

Bindings follow the lexical structure of the program:  When several
bindings with the same name exist, a variable refers to the binding
that is closest to it, starting with its occurrence in the program
and going from inside to outside, and referring to an outermost
binding if no
local binding can be found along the way:

\begin{scheme}
(define x 23)
(define y 42)
(let ((y 43))
  (+ x y)) \ev 66

(let ((y 43))
  (let ((y 44))
    (+ x y))) \ev 67%
\end{scheme}

\chapter{过程}

Definitions can also be used to define
procedures:

\begin{scheme}
(define (f x)
  (+ x 42))

(f 23) \ev 65%
\end{scheme}

A procedure is, slightly simplified, an abstraction of an
expression over objects.  In the example, the first definition defines a procedure
called {\cf f}.  (Note the parentheses around {\cf f x}, which
indicate that this is a procedure definition.)  The expression {\cf (f
  23)} is a procedure call meaning,
roughly, ``evaluate {\cf (+ x 42)} (the body of the procedure) with
{\cf x} bound to 23''.

As procedures are objects, they can be passed to other
procedures:
%
\begin{scheme}
(define (f x)
  (+ x 42))

(define (g p x)
  (p x))

(g f 23) \ev 65%
\end{scheme}

In this example, the body of {\cf g} is evaluated with {\cf p}
bound to {\cf f} and {\cf x} bound to 23, which is equivalent
to {\cf (f 23)}, which evaluates to 65.

In fact, many predefined operations of Scheme are provided not by
syntax, but by variables whose values are procedures.
The {\cf +} operation, for example, which receives
special syntactic treatment in many other languages, is just a regular
identifier in Scheme, bound to a procedure that adds numbers.  The
same holds for {\cf *} and many others:

\begin{scheme}
(define (h op x y)
  (op x y))

(h + 23 42) \ev 65
(h * 23 42) \ev 966%
\end{scheme}

Procedure definitions are not the only way to create procedures.  A
{\cf lambda} expression creates a new procedure as an object, with no
need to specify a name:

\begin{scheme}
((lambda (x) (+ x 42)) 23) \ev 65%
\end{scheme}

The entire expression in this example is a procedure call; {\cf
  (lambda (x) (+ x 42))}, evaluates to a procedure that takes a single
number and adds 42 to it.

\chapter{Procedure calls and syntactic keywords}

Whereas {\cf (+ 23 42)}, {\cf (f 23)}, and {\cf ((lambda (x) (+ x 42))
  23)} are all examples of procedure calls, {\cf lambda} and {\cf
  let} expressions are not.  This is because {\cf let}, even though
it is an identifier, is not a variable, but is instead a \textit{syntactic
  keyword}.  A list that has a
syntactic keyword as its first subexpression obeys special rules determined by
the keyword.  The {\cf define} identifier in a definition is also a
syntactic keyword.  Hence, definitions are also not procedure calls.

The rules for the {\cf lambda} keyword specify that the first
sublist is a list of parameters, and the remaining sublists are the body of
the procedure.  In {\cf let} expressions, the first sublist is a list
of binding specifications, and the remaining sublists constitute a body of
expressions.

Procedure calls can be distinguished from these
\textit{expression types} by
looking for a syntactic keyword in the first position of a list:
if the first position does not contain a syntactic keyword, the expression
is a procedure call.  
The set of syntactic keywords of Scheme is
fairly small, which usually makes this task fairly simple.
It is possible, however, to create new bindings for syntactic keywords.

\chapter{赋值}

Scheme variables bound by definitions or {\cf let} or {\cf lambda}
expressions are not actually bound directly to the objects specified in the
respective bindings, but to locations containing these objects.  The
contents of these locations can subsequently be modified destructively
via \textit{assignment}:
%
\begin{scheme}
(let ((x 23))
  (set! x 42)
  x) \ev 42%
\end{scheme}

In this case, the body of the {\cf let} expression consists of two
expressions which are evaluated sequentially, with the value of the
final expression becoming the value of the entire {\cf let}
expression.  The expression {\cf (set! x 42)} is an assignment, saying
``replace the object in the location referenced by {\cf x} with 42''.
Thus, the previous value of {\cf x}, 23, is replaced by 42.

\chapter{派生语法和宏}

Many of the expression types specified 
as part of the \rsevenrs{} small language
can be translated into more basic expression types.
For example, a {\cf let} expression can be translated
into a procedure call and a {\cf lambda} expression.  The following two
expressions are equivalent:
%
\begin{scheme}
(let ((x 23)
      (y 42))
  (+ x y)) \ev 65

((lambda (x y) (+ x y)) 23 42) \lev 65%
\end{scheme}

Syntax expressions like {\cf let} expressions are called \textit{derived}
because their semantics can be
derived from that of other kinds of expressions by a syntactic
transformation.  Some procedure definitions are also derived expressions.  The
following two definitions are equivalent:

\begin{scheme}
(define (f x)
  (+ x 42))

(define f
  (lambda (x)
    (+ x 42)))%
\end{scheme}

In Scheme, it is possible for a program to create its own derived
expressions by binding syntactic keywords to macros:

\begin{scheme}
(define-syntax def
  (syntax-rules ()
    ((def f (p ...) body)
     (define (f p ...)
       body))))

(def f (x)
  (+ x 42))%
\end{scheme}

The {\cf define-syntax} construct specifies that a parenthesized
structure matching the pattern {\cf (def f (p ...) body)}, where {\cf
  f}, {\cf p}, and {\cf body} are pattern variables, is translated to
{\cf (define (f p ...) body)}.  Thus, the {\cf def} expression appearing in
the example gets translated to:

\begin{scheme}
(define (f x)
  (+ x 42))%
\end{scheme}

The ability to create new syntactic keywords makes Scheme extremely
flexible and expressive, allowing many of the features
built into other languages to be implemented directly in Scheme:
any Scheme programmer can add new expression types.

\chapter{语法数据和数据值Syntactic data and datum values}

\textit{Datum values} constitute a subset of Scheme objects.
These include booleans, numbers, characters, symbols,
and strings as well as lists, vectors, and bytevectors whose elements are datum values.  Each
datum value can be represented textually as a
\textit{syntactic datum}, which can be written out
and read back in without loss of information.
There is in general more than one syntactic datum corresponding to each datum value.
Moreover, each datum value
can be trivially translated to a literal expression in a program by
prepending a {\cf\singlequote} to a corresponding syntactic datum:

\begin{scheme}
'23 \ev 23
'\schtrue{} \ev \schtrue{}
'foo \ev foo
'(1 2 3) \ev (1 2 3)
'\#(1 2 3) \ev \#(1 2 3)%
\end{scheme}

The {\cf\singlequote} shown in the previous examples
is not needed for representations of literal constants other than
symbols and lists.
The syntactic datum {\cf foo} represents a
symbol with name ``foo'', and {\cf 'foo} is a literal expression with
that symbol as its value.  {\cf (1 2 3)} is a syntactic datum that 
represents a list with elements 1, 2, and 3, and {\cf '(1 2 3)} is a literal
expression with this list as its value.  Likewise, {\cf \#(1 2 3)}
is a syntactic datum that represents a vector with elements 1, 2 and 3, and
{\cf '\#(1 2 3)} is the corresponding literal.

Syntactic datums are a superset of Scheme expressions.  Thus, data
can be used to represent Scheme expressions as data objects.  In
particular, symbols can be used to represent identifiers.

\begin{scheme}
'(+ 23 42) \ev (+ 23 42)
'(define (f x) (+ x 42)) \lev (define (f x) (+ x 42))%
\end{scheme}

This facilitates writing programs that operate on Scheme source code,
in particular interpreters and program transformers.

\chapter{继续}

Whenever a Scheme expression is evaluated there is a
\textit{continuation} wanting the result of the
expression.  The continuation represents an entire (default) future
for the computation.  For example, informally the continuation of {\cf 3}
in the expression
%
\begin{scheme}
(+ 1 3)%
\end{scheme}
%
adds 1 to it.  Normally these ubiquitous continuations are hidden
behind the scenes and programmers do not think much about them.  On
rare occasions, however, a programmer needs to deal with
continuations explicitly.  The {\cf call-with-current-continuation}
procedure allows
Scheme programmers to do that by creating a procedure that reinstates
the current continuation.  The {\cf call-with-current-continuation}
procedure accepts a procedure, calls it immediately with an argument
that is an \textit{escape procedure}.  This
escape procedure can then be called with an argument that becomes the
result of the call to {\cf call-with-current-continuation}.  That is,
the escape procedure abandons its own continuation, and reinstates the
continuation of the call to {\cf call-with-current-continuation}.

In the following example, an escape procedure representing the
continuation that adds 1 to its argument is bound to {\cf escape}, and
then called with 3 as an argument.  The continuation of the call to
{\cf escape} is abandoned, and instead the 3 is passed to the
continuation that adds 1:
%
\begin{scheme}
(+ 1 (call-with-current-continuation
       (lambda (escape)
         (+ 2 (escape 3))))) \lev 4%
\end{scheme}
%
An escape procedure has unlimited extent: It can be called after the
continuation it captured has been invoked, and it can be called
multiple times.  This makes {\cf call-with-current-continuation}
significantly more powerful than typical non-local control constructs
such as exceptions in other languages.

\chapter{库}

Scheme 代码可组织为称为\textit{libraries}的组件。每个库包含定义和表达式。它可从其它库导入定义和导出定义到其它库。

以下叫 {\cf (hello)} 的库导出{\cf hello-world}定义和导入base库和display库。{\cf hello-world}是在输出一行{\cf Hello World}的过程:
%
\begin{scheme}
(define-library (hello)
  (export hello-world)
  (import (scheme base)
          (scheme display))
  (begin
    (define (hello-world)
      (display "Hello World")
      (newline))))%
\end{scheme}

\chapter{程序}

库由其它库，最终 Scheme \textit{程序}调用。类似于库，程序包含导入、定义和表达式，还有特定的运行起点。从而一个程序通过它导入的库的传递闭包定义一个Scheme程序。

以下程序通过process-context库的{\cf command-line}过程取得首个命令行参数。然后它用{\cf with-input-from-file}打开文件并使之成为当前输入端口，最后自动关闭。然后，它调用{\cf read-line}过程读入一行文本，再用{\cf write-string}和{\cf newline}输出该行，接着循环至文件结束:
%
\begin{scheme}
(import (scheme base)
        (scheme file)
        (scheme process-context))
(with-input-from-file
  (cadr (command-line))
  (lambda ()
    (let loop ((line (read-line)))
      (unless (eof-object? line)
        (write-string line)
        (newline)
        (loop (read-line))))))%
\end{scheme}

\chapter{REPL}

实现可以提供称为交互会话\defining{REPL}(Read-Eval-Print Loop), 其中可一个一个地输入和处理导入、表达式和定义。REPL 开始时导入base库和其它可能的库。实现可提供REPL从文件读输入的操作模式，这文件一般不是程序，因为可以在非起始处导入。

以下是一个短的REPL会话.  {\cf >} 为输入提示符:

\begin{scheme}
> ; A few simple things
> (+ 2 2)
4
> (sin 4)
Undefined variable: sin
> (import (scheme inexact))
> (sin 4)
-0.756802495307928
> (define sine sin)
> (sine 4)
-0.756802495307928
> ; Guy Steele's three-part test
> ; True is true ...
> \#t
\#t
> ; 100!/99! = 100 ...
> (define (fact n)
    (if (= n 0) 1 (* n (fact (- n 1)))))
> (/ (fact 100) (fact 99))
100
> ; If it returns the *right* complex number,
> ; so much the better ...
> (define (atanh x)
    (/ (- (log (+ 1 x))
          (log (- 1 x)))
       2))
> (atanh -2)
-0.549306144334055+1.5707963267949i%
\end{scheme}

%%% Local Variables: 
%%% mode: latex
%%% End: 
