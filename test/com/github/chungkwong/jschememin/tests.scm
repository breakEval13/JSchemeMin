"(eqv? 'a 'a)","#t"
"(eqv? 'a 'b)","#f"
"(eqv? 2 2)","#t"
"(eqv? 2 2.0)","#f"
"(eqv? '() '())","#t"
"(eqv? 100000000 100000000)","#t"
"(eqv? 0.0 +nan.0)","#f"
"(eqv? (cons 1 2) (cons 1 2))","#f"
"(eqv? (lambda () 1)"
"      (lambda () 2))","#f"
"(let ((p (lambda (x) x)))"
"  (eqv? p p))","#t"
"(eqv? \#f 'nil)","#f%"
"(define gen-counter"
"  (lambda ()"
"    (let ((n 0))"
"      (lambda () (set! n (+ n 1)) n))))"
"(let ((g (gen-counter)))"
"  (eqv? g g))","#t"
"(eqv? (gen-counter) (gen-counter))","#f"
"(define gen-loser"
"  (lambda ()"
"    (let ((n 0))"
"      (lambda () (set! n (+ n 1)) 27))))"
"(let ((g (gen-loser)))"
"  (eqv? g g))","#t"
"(eqv? (gen-loser) (gen-loser))","\unspecified"
""
"(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))"
"         (g (lambda () (if (eqv? f g) 'both 'g))))"
"  (eqv? f g))","\unspecified"
""
"(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))"
"         (g (lambda () (if (eqv? f g) 'g 'both))))"
"  (eqv? f g))","#f%"
"(eqv? '(a) '(a))","\unspecified"
"(eqv? "a" "a")","\unspecified"
"(eqv? '(b) (cdr '(a b)))","\unspecified"
"(let ((x '(a)))"
"  (eqv? x x))","#t%"
"(eq? 'a 'a)","#t"
"(eq? '(a) '(a))","\unspecified"
"(eq? (list 'a) (list 'a))","#f"
"(eq? "a" "a")","\unspecified"
"(eq? "" "")","\unspecified"
"(eq? '() '())","#t"
"(eq? 2 2)","\unspecified"
"(eq? \#\backwhack{}A \#\backwhack{}A)","\unspecified"
"(eq? car car)","#t"
"(let ((n (+ 2 3)))"
"  (eq? n n))","\unspecified"
"(let ((x '(a)))"
"  (eq? x x))","#t"
"(let ((x '\#()))"
"  (eq? x x))","#t"
"(let ((p (lambda (x) x)))"
"  (eq? p p))","#t%"
""
"(equal? 'a 'a)","#t"
"(equal? '(a) '(a))","#t"
"(equal? '(a (b) c)"
"        '(a (b) c))","#t"
"(equal? "abc" "abc")","#t"
"(equal? 2 2)","#t"
"(equal? (make-vector 5 'a)"
"        (make-vector 5 'a))","#t"
"(equal? '\#1=(a b . \#1\#)"
"        '\#2=(a b a b . \#2\#))","#t"
"(equal? (lambda (x) x)"
"        (lambda (y) y))","\unspecified%"
"#t","#t"
"#f","#f"
"'#f","#f%"
"(not #t)","#f"
"(not 3)","#f"
"(not (list 3))","#f"
"(not #f)","#t"
"(not '())","#f"
"(not (list))","#f"
"(not 'nil)","#f%"
"(boolean? #f)","#t"
"(boolean? 0)","#f"
"(boolean? '())","#f%"
"(define x (list 'a 'b 'c))"
"(define y x)"
"y","(a b c)"
"(list? y)","#t"
"(set-cdr! x 4)","\unspecified"
"x","(a . 4)"
"(eqv? x y)","#t"
"y","(a . 4)"
"(list? y)","#f"
"(set-cdr! x x)","\unspecified"
"(list? x)","#f%"
"(pair? '(a . b))","#t"
"(pair? '(a b c))","#t"
"(pair? '())","#f"
"(pair? '\#(a b))","#f%"
"(cons 'a '())","(a)"
"(cons '(a) '(b c d))","((a) b c d)"
"(cons "a" '(b c))","("a" b c)"
"(cons 'a 3)","(a . 3)"
"(cons '(a b) 'c)","((a b) . c)%"
"(car '(a b c))","a"
"(car '((a) b c d))","(a)"
"(car '(1 . 2))","1"
"(car '())","\scherror%"
"(cdr '((a) b c d))","(b c d)"
"(cdr '(1 . 2))","2"
"(cdr '())","\scherror%"
"(define (f) (list 'not-a-constant-list))"
"(define (g) '(constant-list))"
"(set-car! (f) 3)","\unspecified"
"(set-car! (g) 3)","\scherror%"
"        (list? '(a b c))","#t"
"        (list? '())","#t"
"        (list? '(a . b))","#f"
"        (let ((x (list 'a)))"
"          (set-cdr! x x)"
"          (list? x))","#f%"
"(make-list 2 3)","(3 3)%"
"(list 'a (+ 3 4) 'c)","(a 7 c)"
"(list)","()%"
"(length '(a b c))","3"
"(length '(a (b) (c d e)))","3"
"(length '())","0%"
"(append '(x) '(y))","(x y)"
"(append '(a) '(b c d))","(a b c d)"
"(append '(a (b)) '((c)))","(a (b) (c))%"
"(append '(a b) '(c . d))","(a b c . d)"
"(append '() 'a)","a%"
"(reverse '(a b c))","(c b a)"
"(reverse '(a (b c) d (e (f))))  \lev  ((e (f)) d (b c) a)%"
"(list-ref '(a b c d) 2)","c"
"(list-ref '(a b c d)"
"          (exact (round 1.8))) \lev  c%"
"(let ((ls (list 'one 'two 'five!)))"
"  (list-set! ls 2 'three)"
"  ls)      \lev  (one two three)"
""
"(list-set! '(0 1 2) 1 "oops")  \lev  \scherror  ; constant list%"
"(memq 'a '(a b c))","(a b c)"
"(memq 'b '(a b c))","(b c)"
"(memq 'a '(b c d))","#f"
"(memq (list 'a) '(b (a) c))","#f"
"(member (list 'a)"
"        '(b (a) c))","((a) c)"
"(member "B""
"        '("a" "b" "c")"
"        string-ci=?)","("b" "c")"
"(memq 101 '(100 101 102))","\unspecified"
"(memv 101 '(100 101 102))","(101 102)%"
"(define e '((a 1) (b 2) (c 3)))"
"(assq 'a e)","(a 1)"
"(assq 'b e)","(b 2)"
"(assq 'd e)","#f"
"(assq (list 'a) '(((a)) ((b)) ((c))))","#f"
"(assoc (list 'a) '(((a)) ((b)) ((c))))","((a))"
"(assoc 2.0 '((1 1) (2 4) (3 9)) =)","(2 4)"
"(assq 5 '((2 3) (5 7) (11 13)))","\unspecified"
"(assv 5 '((2 3) (5 7) (11 13)))","(5 7)%"
"(define a '(1 8 2 8)) ; a may be immutable"
"(define b (list-copy a))"
"(set-car! b 3)        ; b is mutable"
"b","(3 8 2 8)"
"a","(1 8 2 8)%"
"(symbol? 'foo)","#t"
"(symbol? (car '(a b)))","#t"
"(symbol? "bar")","#f"
"(symbol? 'nil)","#t"
"(symbol? '())","#f"
"(symbol? #f)","#f%"
"(symbol->string 'flying-fish)",""flying-fish""
"(symbol->string 'Martin)",""Martin""
"(symbol->string"
"   (string->symbol "Malvina"))",""Malvina"%"
"(string->symbol "mISSISSIppi")  \lev%"
"  mISSISSIppi"
"(eqv? 'bitBlt (string->symbol "bitBlt"))     \lev  #t"
"(eqv? 'LollyPop"
"     (string->symbol"
"       (symbol->string 'LollyPop)))  \lev  #t"
"(string=? "K. Harper, M.D.""
"          (symbol->string"
"            (string->symbol "K. Harper, M.D.")))  \lev  #t%"
"(digit-value \#\backwhack{}3)","3"
"(digit-value \#\backwhack{}x0664)","4"
"(digit-value \#\backwhack{}x0AE6)","0"
"(digit-value \#\backwhack{}x0EA6)","#f%"
"(define (f) (make-string 3 \sharpsign\backwhack{}*))"
"(define (g) "***")"
"(string-set! (f) 0 \sharpsign\backwhack{}?)","\unspecified"
"(string-set! (g) 0 \sharpsign\backwhack{}?)","\scherror"
"(string-set! (symbol->string 'immutable)"
"             0"
"             \sharpsign\backwhack{}?)","\scherror%"
"(define a "12345")"
"(define b (string-copy "abcde"))"
"(string-copy! b 1 a 0 2)"
"b",""a12de"%"
"(vector 'a 'b 'c)","\#(a b c)%"
"(vector-ref '\#(1 1 2 3 5 8 13 21)"
"            5)  \lev  8"
"(vector-ref '\#(1 1 2 3 5 8 13 21)"
"            (exact"
"             (round (* 2 (acos -1))))) \lev 13%"
"(let ((vec (vector 0 '(2 2 2 2) "Anna")))"
"  (vector-set! vec 1 '("Sue" "Sue"))"
"  vec)      \lev  \#(0 ("Sue" "Sue") "Anna")"
""
"(vector-set! '\#(0 1 2) 1 "doe")  \lev  \scherror  ; constant vector%"
"(vector->list '\#(dah dah didah))  \lev  (dah dah didah)"
"(vector->list '\#(dah dah didah) 1 2) \lev (dah)"
"(list->vector '(dididit dah))   \lev  \#(dididit dah)%"
"(string->vector "ABC")","\#(\#\backwhack{}A \#\backwhack{}B \#\backwhack{}C)"
"(vector->string"
"  \#(\#\backwhack{}1 \#\backwhack{}2 \#\backwhack{}3)",""123""
"(define a \#(1 8 2 8)) ; a may be immutable"
"(define b (vector-copy a))"
"(vector-set! b 0 3)   ; b is mutable"
"b","\#(3 8 2 8)"
"(define c (vector-copy b 1 3))"
"c","\#(8 2)%"
"(define a (vector 1 2 3 4 5))"
"(define b (vector 10 20 30 40 50))"
"(vector-copy! b 1 a 0 2)"
"b","\#(10 1 2 40 50)%"
"(vector-append \#(a b c) \#(d e f)) \lev \#(a b c d e f)%"
"(define a (vector 1 2 3 4 5))"
"(vector-fill! a 'smash 2 4)"
"a \lev \#(1 2 smash smash 5)%"
"\#u8(0 10 5)%"
"(make-bytevector 2 12)","\#u8(12 12)%"
"(bytevector 1 3 5 1 3 5)","\#u8(1 3 5 1 3 5)"
"(bytevector)","\#u8()%"
"(bytevector-u8-ref '\#u8(1 1 2 3 5 8 13 21)"
"            5)  \lev  8%"
"(let ((bv (bytevector 1 2 3 4)))"
"  (bytevector-u8-set! bv 1 3)"
"  bv) \lev \#u8(1 3 3 4)%"
"(define a \#u8(1 2 3 4 5))"
"(bytevector-copy a 2 4))","\#u8(3 4)%"
"(define a (bytevector 1 2 3 4 5))"
"(define b (bytevector 10 20 30 40 50))"
"(bytevector-copy! b 1 a 0 2)"
"b","\#u8(10 1 2 40 50)%"
"(bytevector-append \#u8(0 1 2) \#u8(3 4 5)) \lev \#u8(0 1 2 3 4 5)%"
"(utf8->string \#u8(\#x41))",""A""
"(string->utf8 "$\lambda$")","\#u8(\#xCE \#xBB)%"
"(procedure? car)","#t"
"(procedure? 'car)","#f"
"(procedure? (lambda (x) (* x x)))","#t"
"(procedure? '(lambda (x) (* x x)))","#f"
"(call-with-current-continuation procedure?)","#t%"
"(apply + (list 3 4))","7"
""
"(define compose"
"  (lambda (f g)"
"    (lambda args"
"      (f (apply g args)))))"
""
"((compose sqrt *) 12 75)","30%"
"(map cadr '((a b) (d e) (g h)))   \lev  (b e h)"
""
"(map (lambda (n) (expt n n))"
"     '(1 2 3 4 5))                \lev  (1 4 27 256 3125)"
""
"(map + '(1 2 3) '(4 5 6 7))","(5 7 9)"
""
"(let ((count 0))"
"  (map (lambda (ignored)"
"         (set! count (+ count 1))"
"         count)"
"       '(a b)))","(1 2) \var{or} (2 1)%"
"(string-map char-foldcase "AbdEgH") \lev  "abdegh""
""
"(string-map"
" (lambda (c)"
"   (integer->char (+ 1 (char->integer c))))"
" "HAL")                \lev  "IBM""
""
"(string-map"
" (lambda (c k)"
"   ((if (eqv? k \sharpsign\backwhack{}u) char-upcase char-downcase)"
"    c))"
" "studlycaps xxx""
" "ululululul")   \lev   "StUdLyCaPs"%"
"(vector-map cadr '\#((a b) (d e) (g h)))   \lev  \#(b e h)"
""
"(vector-map (lambda (n) (expt n n))"
"            '\#(1 2 3 4 5))                \lev  \#(1 4 27 256 3125)"
""
"(vector-map + '\#(1 2 3) '\#(4 5 6 7))       \lev  \#(5 7 9)"
""
"(let ((count 0))"
"  (vector-map"
"   (lambda (ignored)"
"     (set! count (+ count 1))"
"     count)"
"   '\#(a b)))","\#(1 2) \var{or} \#(2 1)%"
"(let ((v (make-vector 5)))"
"  (for-each (lambda (i)"
"              (vector-set! v i (* i i)))"
"            '(0 1 2 3 4))"
"  v)","\#(0 1 4 9 16)%"
"(let ((v '()))"
"  (string-for-each"
"   (lambda (c) (set! v (cons (char->integer c) v)))"
"   "abcde")"
"  v)","(101 100 99 98 97)%"
"(let ((v (make-list 5)))"
"  (vector-for-each"
"   (lambda (i) (list-set! v i (* i i)))"
"   '\#(0 1 2 3 4))"
"  v)","(0 1 4 9 16)%"
"(call-with-current-continuation"
"  (lambda (exit)"
"    (for-each (lambda (x)"
"                (if (negative? x)"
"                    (exit x)))"
"              '(54 0 37 -3 245 19))"
"    #t))","-3"
""
"(define list-length"
"  (lambda (obj)"
"    (call-with-current-continuation"
"      (lambda (return)"
"        (letrec ((r"
"                  (lambda (obj)"
"                    (cond ((null? obj) 0)"
"                          ((pair? obj)"
"                           (+ (r (cdr obj)) 1))"
"                          (else (return #f))))))"
"          (r obj))))))"
""
"(list-length '(1 2 3 4))","4"
""
"(list-length '(a b . c))","#f%"
"(call-with-values (lambda () (values 4 5))"
"                  (lambda (a b) b))","5"
""
"(call-with-values * -)","-1%"
"(let ((path '())"
"      (c \#f))"
"  (let ((add (lambda (s)"
"               (set! path (cons s path)))))"
"    (dynamic-wind"
"      (lambda () (add 'connect))"
"      (lambda ()"
"        (add (call-with-current-continuation"
"               (lambda (c0)"
"                 (set! c c0)"
"                 'talk1))))"
"      (lambda () (add 'disconnect)))"
"    (if (< (length path) 4)"
"        (c 'talk2)"
"        (reverse path))))"
"    \lev (connect talk1 disconnect"
"               connect talk2 disconnect)%"
"(call-with-current-continuation"
" (lambda (k)"
"  (with-exception-handler"
"   (lambda (x)"
"    (display "condition: ")"
"    (write x)"
"    (newline)"
"    (k 'exception))"
"   (lambda ()"
"    (+ 1 (raise 'an-error))))))","exception"
" \>{\em and prints}  condition: an-error"
""
"(with-exception-handler"
" (lambda (x)"
"  (display "something went wrong\backwhack{}n"))"
" (lambda ()"
"  (+ 1 (raise 'an-error))))"
" \>{\em prints}  something went wrong%"
"(with-exception-handler"
"  (lambda (con)"
"    (cond"
"      ((string? con)"
"       (display con))"
"      (else"
"       (display "a warning has been issued")))"
"    42)"
"  (lambda ()"
"    (+ (raise-continuable "should be a number")"
"       23)))"
"   {\it prints:} should be a number","65%"
"(define (null-list? l)"
"  (cond ((pair? l) \#f)"
"        ((null? l) \#t)"
"        (else"
"          (error"
"            "null-list?: argument out of domain""
"            l))))%"
"(eval '(* 7 3) (environment '(scheme base)))","21"
""
"(let ((f (eval '(lambda (f x) (f x x))"
"               (null-environment 5))))"
"  (f + 10))","20"
"(eval '(define foo 32)"
"      (environment '(scheme base)))","{\it{} error is signaled}%"
"(parameterize"
"    ((current-output-port"
"      (open-output-string)))"
"    (display "piece")"
"    (display " by piece ")"
"    (display "by piece.")"
"    (newline)"
"    (get-output-string (current-output-port)))"
"\lev "piece by piece by piece.\backwhack{}n"%"
"(get-environment-variable "PATH") \lev "/usr/local/bin:/usr/bin:/bin"%"
"(get-environment-variables) \lev (("USER" . "root") ("HOME" . "/"))%"
""
"(features)","(r7rs ratios exact-complex full-unicode"
"   gnu-linux little-endian "
"   fantastic-scheme"
"   fantastic-scheme-1.0"
"   space-ship-control-system)"%